# Compares generated data w/ SNP data.

# Generated by Conumee 2.0. Y-chromosome is ignored due to all samples being
# cisgender female individuals. Segment averages are used, sorted and fitted to 
# the annotation, as well as bin values to see how it can be used versus 
# algorithms. 

library("tidyverse")

# Generalized algorithm.
matchingAlgo <- function(caseName, tech, whichData){
  
  # Pre-processing.
  case <- unique(list.files(path = paste0("./cases/", caseName, "/maskedMethylation"), 
                     pattern = ".idat") %>% str_remove(pattern = "_Red.idat") %>% 
                    str_remove(pattern = "_Grn.idat"))
  actualCaseOutput <- paste0("./Outputs/", tech, "/", whichData, "/", case, ".csv")
  cnv <- list.files(path = paste0("./cases/", caseName, "/cnvs"), pattern = ".csv")
  cnvPath <- paste0("./cases/", caseName, "/cnvs/", cnv)
  
  cnv <- read_csv(cnvPath)
  case <- read_csv(actualCaseOutput)
  
  cnv <- cnv %>% dplyr::select(-c("GDC_Aliquot")) %>%
    mutate(CNVStatus = case_when(cnv$Segment_Mean > 0.3 ~ "Amplification",
                                 cnv$Segment_Mean < -0.3 ~ "Deletion",
                                 TRUE ~ "Normal")) %>% filter(cnv$Num_Probes > 100) %>% 
    dplyr::select(-c("Num_Probes", "...1")) %>% mutate(type = "SNP") %>% dplyr::rename(chrom = Chromosome, loc.start = Start, loc.end = End, seg.mean = Segment_Mean)
  
  # Change labels based on tech + add rename if necessary to match the above 
  # dplyr::rename.
  case <- case %>% dplyr::select(-c("ID", "bstat")) %>% 
    mutate(CNVStatus = case_when(case$seg.mean > 0.2 ~ "Amplification",
                                 case$seg.mean < -0.2 ~ "Deletion",
                                 TRUE ~ "Normal"), 
           chrom = as.numeric(str_remove_all(chrom, "chr"))) %>% 
    dplyr::arrange(chrom) %>% mutate(type = tech) %>%
    dplyr::select(-c("num.mark", "pval", "seg.median", "...1"))
  comb <- rbind(cnv, case)
  
  # Binning algorithm.
  bins <- list()
  chromsomes <- unique(comb$chrom)
  for(crs in chromsomes){
    bins[crs] <- list(comb %>% dplyr::filter(chrom == crs))
  }
  bins # Change back to bins after testing.
}

# Metrics: Consider location, number of outputs, indication of software v. SNP.
# Specifics:
# - Software output per chromosome.
# - Populated accuracy averages.
# - Probe exclusions.
# - Segments with no corresponding probes.
metrics <- function(matchedChrom){
  mets <- data.frame(Chromosomes = c(1:22, "X", "Y"), softwareOutput = c(0), 
                     popAccAvg = c(0), 
                     falseSegments = c(0)) 
  
  #Software-produced counts on segments.
  softCounts <- c()
  for(chroms in matchedChrom){
    SoftOutputCount <- nrow(chroms) - nrow(chroms %>% filter(type == "SNP"))
    softCounts <- c(softCounts, SoftOutputCount)
  }
  mets$softwareOutput <- softCounts
  
  # Dealing with no software data on chromosomes.
  exclusions <- mets %>% filter(softwareOutput == 0)
  exclusions$popAccAvg <- NA
  exclusions$detectAcc <- NA
  mets <- mets %>% filter(softwareOutput > 0)
  
  MatchedChroms <- matchedChrom[c(mets$Chromosomes)] 
  
  # Populated accuracy averages (weighted).
  # Filter into subsets by locations generated by software. Check the accuracy 
  # of the CNVStatus of the software generated CNV with the SNP, producing a 
  # ratio for accuracy. Then, normalize over the chromosome as a percentage.
  
  # Integrated with false segments, detected when the subset is null.
  falsePositives <- c()
  chromosomalAccuracy <- c()
  chromExclusion <- c()
  for(chroms in MatchedChroms){
    # falseSegments.
    fpChrom <- 0
    
    # Each generated segment is compared to corresponding probes.
    segAccuracies <- c()
    
    softs <- chroms %>% filter(!(type == "SNP"))
    
    for(dfs in 1:nrow(softs)){
      
      # Per segment processing with further filtering for probes such that at least 50% of the probe lies within the segment generated by the software.
      seg <- softs[dfs, ]
      snpSubset <- chroms %>% filter(type == "SNP") %>% filter(loc.start > seg$loc.start & loc.end < seg$loc.end)
      segArr <- seg$loc.end - seg$loc.start
      
      # Edge cases.
      # There is a maximum of one probe that can be partially inter-sectional, at at least 50% of it must be intersecting.
      topEdge <- chroms %>% filter(loc.start < seg$loc.start & loc.end > seg$loc.start & ((loc.end - seg$loc.start)/(loc.end - loc.start) > 0.5), type == "SNP")
      topEdge$loc.start <- seg$loc.start # To normalize it to within the segment.
      bottomEdge <- chroms %>% filter(loc.start < seg$loc.end & loc.end > seg$loc.end & loc.start > seg$loc.start & ((seg$loc.end - loc.start)/(loc.end - loc.start) > 0.5), type == "SNP")
      bottomEdge$loc.end <- seg$loc.end # Normalize it to within the segment.
      snpSubset <- rbind(snpSubset, topEdge, bottomEdge) %>% dplyr::arrange(loc.start)
    
      # Counting area of deletions, amplifications & normals.
      deletions <- c()
      amplifications <- c()
      normals <- c()
      i = 1
      if(nrow(snpSubset > 0)){
        while(i < nrow(snpSubset)){
          snp <- snpSubset[i, ]
          outindex <- 0
          j <- i + 1
          while(j < nrow(snpSubset)){
            endBlock <- snpSubset[j, ]
            if(endBlock$CNVStatus != snp$CNVStatus){
              outindex <- j - 1
              break
            }
            j <- j + 1
          } # Searching for block of certain type.
          snpSect <- snpSubset[i:outindex, ]
          areas <- max(snpSect$loc.end) - min(snpSect$loc.start)
          if(snp$CNVStatus == "Deletion"){ deletions <- c(deletions, areas)}
          if(snp$CNVStatus == "Amplification"){ amplifications <- c(amplifications, areas)}
          if(snp$CNVStatus == "Normal") {normals <- c(normals, areas)}
          
          i <- j + 1
        }
      } else {print("Invalid case?")}
     
      
      deletions <- sum(deletions)
      amplifications <- sum(amplifications)
      normals <- sum(normals)
      
      if(snp$CNVStatus == "Deletion"){ 
        i <- (deletions/segArr)
        if(i > 1){
          i <- 1
        }
        segAccuracies <- c(segAccuracies, i) 
      }
      if(snp$CNVStatus == "Amplification"){ 
        i <- (amplifications/segArr)
        if(i > 1){
          i <- 1
        }
        segAccuracies <- c(segAccuracies, i) }
      else {
        i <- (normals/segArr)
        if(i > 1){
          i <- 1
        }
        segAccuracies <- c(segAccuracies, i)}
    }
    # Final returns.
    segTotal <- sum(segAccuracies)/length(segAccuracies)
    chromosomalAccuracy <- c(chromosomalAccuracy, segTotal)
    falsePositives <- c(falsePositives, fpChrom)
   
  }
  mets$falseSegments <- falsePositives
  mets$popAccAvg <- chromosomalAccuracy
  
  print("Excluded Chromosomes")
  print(exclusions)
  
  print("Actual chromsomes returned.")
  print(mets)
  mets
}

barcodes <- list.dirs("./cases", recursive = F)[-c(1)] 
barcodes <- str_remove(barcodes, "./cases/")

A9HX <- metrics(matchingAlgo("TCGA-3B-A9HX", "Conumee", "LMS"))
A6Z2 <- metrics(matchingAlgo("TCGA-DX-A6Z2", "Conumee", "LMS"))
A7EL <- metrics(matchingAlgo("TCGA-DX-A7EL", "Conumee", "LMS"))
A7EN <- metrics(matchingAlgo("TCGA-DX-A7EN", "Conumee", "LMS"))
A48O <- metrics(matchingAlgo("TCGA-DX-A48O", "Conumee", "LMS"))
A48P <- metrics(matchingAlgo("TCGA-DX-A48P", "Conumee", "LMS"))
A42W <- metrics(matchingAlgo("TCGA-K1-A42W", "Conumee", "LMS"))

# A6BA, A9HQ and A3UC are not analyzed.
A6BA <- matchingAlgo("TCGA-DX-A6BA", "Conumee", "LMS")
A3UC <- metrics(matchingAlgo("TCGA-DX-A3UC", "Conumee", "LMS"))
A9HQ <- metrics(matchingAlgo("TCGA-3B-A9HQ", "Conumee", "LMS"))


